// github.com/shawn0326/three.path
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t.THREE||{},t.THREE)}(this,(function(t,e){"use strict";function s(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(s){if("default"!==s){var r=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(e,s,r.get?r:{enumerable:!0,get:function(){return t[s]}})}})),e.default=t,Object.freeze(e)}var r=s(e);class i{constructor(){this.pos=new r.Vector3,this.dir=new r.Vector3,this.right=new r.Vector3,this.up=new r.Vector3,this.dist=0,this.widthScale=1,this.sharp=!1}lerpPathPoints(t,e,s){this.pos.lerpVectors(t.pos,e.pos,s),this.dir.lerpVectors(t.dir,e.dir,s),this.up.lerpVectors(t.up,e.up,s),this.right.lerpVectors(t.right,e.right,s),this.dist=(e.dist-t.dist)*s+t.dist,this.widthScale=(e.widthScale-t.widthScale)*s+t.widthScale}copy(t){this.pos.copy(t.pos),this.dir.copy(t.dir),this.up.copy(t.up),this.right.copy(t.right),this.dist=t.dist,this.widthScale=t.widthScale}}const n=new r.Vector3,o=new r.Vector3,a=new r.Vector3,u=new r.Matrix4,h=new r.QuadraticBezierCurve3;class c extends r.BufferGeometry{constructor(t=3e3,e=!1){super(),isNaN(t)?this._initByData(t.pathPointList,t.options,t.usage,e):this._initByMaxVertex(t,e)}_initByMaxVertex(t,e){this.setAttribute("position",new r.BufferAttribute(new Float32Array(3*t),3).setUsage(r.DynamicDrawUsage)),this.setAttribute("normal",new r.BufferAttribute(new Float32Array(3*t),3).setUsage(r.DynamicDrawUsage)),this.setAttribute("uv",new r.BufferAttribute(new Float32Array(2*t),2).setUsage(r.DynamicDrawUsage)),e&&this.setAttribute("uv2",new r.BufferAttribute(new Float32Array(2*t),2).setUsage(r.DynamicDrawUsage)),this.drawRange.start=0,this.drawRange.count=0,this.setIndex(t>65536?new r.Uint32BufferAttribute(3*t,1):new r.Uint16BufferAttribute(3*t,1))}_initByData(t,e={},s,i){const n=d(t,e,i);n&&0!==n.count?(this.setAttribute("position",new r.BufferAttribute(new Float32Array(n.position),3).setUsage(s||r.StaticDrawUsage)),this.setAttribute("normal",new r.BufferAttribute(new Float32Array(n.normal),3).setUsage(s||r.StaticDrawUsage)),this.setAttribute("uv",new r.BufferAttribute(new Float32Array(n.uv),2).setUsage(s||r.StaticDrawUsage)),i&&this.setAttribute("uv2",new r.BufferAttribute(new Float32Array(n.uv2),2).setUsage(s||r.StaticDrawUsage)),this.setIndex(n.position.length/3>65536?new r.Uint32BufferAttribute(n.indices,1):new r.Uint16BufferAttribute(n.indices,1))):this._initByMaxVertex(2,i)}update(t,e={}){const s=!!this.getAttribute("uv2"),r=d(t,e,s);r?(this._updateAttributes(r.position,r.normal,r.uv,s?r.uv2:null,r.indices),this.drawRange.count=r.count):this.drawRange.count=0}_resizeAttribute(t,e){let s=this.getAttribute(t);for(;s.array.length<e;){const e=s.array.length,i=new r.BufferAttribute(new Float32Array(2*e),s.itemSize,s.normalized);i.name=s.name,i.usage=s.usage,this.setAttribute(t,i),s=i}}_resizeIndex(t){let e=this.getIndex();for(;e.array.length<t;){const t=e.array.length,s=new r.BufferAttribute(2*t>65535?new Uint32Array(2*t):new Uint16Array(2*t),1);s.name=e.name,s.usage=e.usage,this.setIndex(s),e=s}}_updateAttributes(t,e,s,r,i){this._resizeAttribute("position",t.length);const n=this.getAttribute("position");n.array.set(t,0),n.updateRange.count=t.length,n.needsUpdate=!0,this._resizeAttribute("normal",e.length);const o=this.getAttribute("normal");o.array.set(e,0),o.updateRange.count=e.length,o.needsUpdate=!0,this._resizeAttribute("uv",s.length);const a=this.getAttribute("uv");if(a.array.set(s,0),a.updateRange.count=s.length,a.needsUpdate=!0,r){this._resizeAttribute("uv2",r.length);const t=this.getAttribute("uv2");t.array.set(r,0),t.updateRange.count=r.length,t.needsUpdate=!0}this._resizeIndex(i.length);const u=this.getIndex();u.set(i,0),u.updateRange.count=i.length,u.needsUpdate=!0}}function d(t,e,s=!1){const n=e.width||.1,o=void 0!==e.progress?e.progress:1,a=void 0===e.arrow||e.arrow,u=void 0!==e.side?e.side:"both",h=n/2,c="both"!==u?n/2:n,d=t.distance(),l=o*d;if(0==d)return null;const p=h/c,y=h/d;let g=0;const f=[],w=[],b=[],A=[],m=[];let x=0;const z=new r.Vector3,V=new r.Vector3,U=new r.Vector3,v=new r.Vector3,_=new r.Vector3,B=new r.Vector3;function S(t){const e=0===f.length,r=t.sharp&&!e,i=t.dist/c,n=t.dist/d,o=t.dir,a=t.up,l=t.right;if("left"!==u?z.copy(l).multiplyScalar(h*t.widthScale):z.set(0,0,0),"right"!==u?V.copy(l).multiplyScalar(-h*t.widthScale):V.set(0,0,0),z.add(t.pos),V.add(t.pos),r){U.fromArray(f,f.length-6).sub(V),v.fromArray(f,f.length-3).sub(z);const t=U.length()-v.length();let e,r;t>0?(e=U,r=V):(e=v,r=z),_.copy(e).setLength(Math.abs(t)).add(r);let u=B.copy(r).sub(_).normalize().dot(o)*B.copy(r).sub(_).length()*2;B.copy(o).setLength(u).add(_),t>0?(f.push(_.x,_.y,_.z,z.x,z.y,z.z,V.x,V.y,V.z,z.x,z.y,z.z,B.x,B.y,B.z,z.x,z.y,z.z),x+=6,m.push(x-6,x-8,x-7,x-6,x-7,x-5,x-4,x-6,x-5,x-2,x-4,x-1),g+=12):(f.push(V.x,V.y,V.z,_.x,_.y,_.z,V.x,V.y,V.z,z.x,z.y,z.z,V.x,V.y,V.z,B.x,B.y,B.z),x+=6,m.push(x-6,x-8,x-7,x-6,x-7,x-5,x-6,x-5,x-3,x-2,x-3,x-1),g+=12),w.push(a.x,a.y,a.z,a.x,a.y,a.z,a.x,a.y,a.z,a.x,a.y,a.z,a.x,a.y,a.z,a.x,a.y,a.z),b.push(i-p,0,i-p,1,i,0,i,1,i+p,0,i+p,1),s&&A.push(n-y,0,n-y,1,n,0,n,1,n+y,0,n+y,1)}else f.push(V.x,V.y,V.z,z.x,z.y,z.z),w.push(a.x,a.y,a.z,a.x,a.y,a.z),b.push(i,0,i,1),s&&A.push(n,0,n,1),x+=2,e||(m.push(x-2,x-4,x-3,x-2,x-3,x-1),g+=6)}const M=new r.Vector3;let P;if(l>0)for(let e=0;e<t.count;e++){const s=t.array[e];if(s.dist>l){const r=t.array[e-1];P=new i;const n=(l-r.dist)/(s.dist-r.dist);P.lerpPathPoints(r,s,n),S(P);break}S(s)}else P=t.array[0];return a&&(P=P||t.array[t.count-1],function(t){const e=t.dir,r=t.up,i=t.right,o=t.dist/c,a=t.dist/d;"left"!==u?z.copy(i).multiplyScalar(2*h):z.set(0,0,0),"right"!==u?V.copy(i).multiplyScalar(2*-h):V.set(0,0,0),M.copy(e).setLength(3*h),z.add(t.pos),V.add(t.pos),M.add(t.pos),f.push(V.x,V.y,V.z,z.x,z.y,z.z,M.x,M.y,M.z),w.push(r.x,r.y,r.z,r.x,r.y,r.z,r.x,r.y,r.z),b.push(o,"both"!==u?"right"!==u?-2:0:-.5,o,"both"!==u?"left"!==u?2:0:1.5,o+1.5,"both"!==u?0:.5),s&&A.push(a,"both"!==u?"right"!==u?-2:0:-.5,a,"both"!==u?"left"!==u?2:0:1.5,a+1.5*n/d,"both"!==u?0:.5),x+=3,m.push(x-1,x-3,x-2),g+=3}(P)),{position:f,normal:w,uv:b,uv2:A,indices:m,count:g}}function l(t,e,s=!1){const n=e.radius||.1,o=void 0!==e.progress?e.progress:1,a=Math.max(2,e.radialSegments||8),u=e.startRad||0,h=2*n*Math.PI,c=t.distance(),d=o*c;if(0==d)return null;let l=0;const p=[],y=[],g=[],f=[],w=[];let b=0;const A=new r.Vector3;function m(t,e,r){const i=0===p.length,n=t.dist/h,o=t.dist/c;for(let i=0;i<=r;i++){let a=i;a==r&&(a=0),A.copy(t.up).applyAxisAngle(t.dir,u+2*Math.PI*a/r).normalize(),p.push(t.pos.x+A.x*e*t.widthScale,t.pos.y+A.y*e*t.widthScale,t.pos.z+A.z*e*t.widthScale),y.push(A.x,A.y,A.z),g.push(n,i/r),s&&f.push(o,i/r),b++}if(!i){const t=b-2*(r+1),e=b-(r+1);for(let s=0;s<r;s++)w.push(e+s,t+s,t+s+1,e+s,t+s+1,e+s+1),l+=6}}if(d>0)for(let e=0;e<t.count;e++){const s=t.array[e];if(s.dist>d){const r=t.array[e-1],o=new i,u=(d-r.dist)/(s.dist-r.dist);o.lerpPathPoints(r,s,u),m(o,n,a);break}m(s,n,a)}return{position:p,normal:y,uv:g,uv2:f,indices:w,count:l}}t.PathGeometry=c,t.PathPointList=class{constructor(){this.array=[],this.count=0}set(t,e=.1,s=10,i=null,n=!1){if((t=t.slice(0)).length<2)return console.warn("PathPointList: points length less than 2."),void(this.count=0);n&&!t[0].equals(t[t.length-1])&&t.push((new r.Vector3).copy(t[0]));for(let r=0,o=t.length;r<o;r++)if(0===r)this._start(t[r],t[r+1],i);else if(r===o-1)if(n){this._corner(t[r],t[1],e,s,i);const n=this.array[0].dist;this.array[0].copy(this.array[this.count-1]),this.array[0].dist=n}else this._end(t[r]);else this._corner(t[r],t[r+1],e,s,i)}distance(){return this.count>0?this.array[this.count-1].dist:0}_getByIndex(t){return this.array[t]||(this.array[t]=new i),this.array[t]}_start(t,e,s){this.count=0;const r=this._getByIndex(this.count);if(r.pos.copy(t),r.dir.subVectors(e,t),s)r.up.copy(s);else{let t=Number.MAX_VALUE;const e=Math.abs(r.dir.x),s=Math.abs(r.dir.y),i=Math.abs(r.dir.z);e<t&&(t=e,r.up.set(1,0,0)),s<t&&(t=s,r.up.set(0,1,0)),i<t&&r.up.set(0,0,1)}r.right.crossVectors(r.dir,r.up).normalize(),r.up.crossVectors(r.right,r.dir).normalize(),r.dist=0,r.widthScale=1,r.sharp=!1,r.dir.normalize(),this.count++}_end(t){const e=this.array[this.count-1],s=this._getByIndex(this.count);s.pos.copy(t),s.dir.subVectors(t,e.pos);const r=s.dir.length();s.dir.normalize(),s.up.copy(e.up);const i=n.crossVectors(e.dir,s.dir);if(i.length()>Number.EPSILON){i.normalize();const t=Math.acos(Math.min(Math.max(e.dir.dot(s.dir),-1),1));s.up.applyMatrix4(u.makeRotationAxis(i,t))}s.right.crossVectors(s.dir,s.up).normalize(),s.dist=e.dist+r,s.widthScale=1,s.sharp=!1,this.count++}_corner(t,e,s,r,i){if(s>0&&r>0){const a=function(t,e,s,r,i,a){const u=n.subVectors(e,t),h=o.subVectors(s,e),c=u.length(),d=h.length();u.normalize(),h.normalize();const l=Math.min(.999999*(i?c/2:c),r);a.v0.copy(e).sub(u.multiplyScalar(l)),a.v1.copy(e);const p=Math.min(d/2*.999999,r);return a.v2.copy(e).add(h.multiplyScalar(p)),a}(this.array[this.count-1].pos,t,e,s,this.count-1==0,h),u=a.getPoints(r);for(let t=0;t<r;t++)this._sharpCorner(u[t],u[t+1],i,0===t?1:0);u[r].equals(e)||this._sharpCorner(u[r],e,i,2)}else this._sharpCorner(t,e,i,0,!0)}_sharpCorner(t,e,s,r=0,i=!1){const h=this.array[this.count-1],c=this._getByIndex(this.count),d=n.subVectors(t,h.pos),l=o.subVectors(e,t),p=d.length();if(d.normalize(),l.normalize(),c.pos.copy(t),1===r?c.dir.copy(d):2===r?c.dir.copy(l):(c.dir.addVectors(d,l),c.dir.normalize()),s)1===c.dir.dot(s)?c.right.crossVectors(l,s).normalize():c.right.crossVectors(c.dir,s).normalize(),c.up.crossVectors(c.right,c.dir).normalize();else{c.up.copy(h.up);const t=a.crossVectors(h.dir,c.dir);if(t.length()>Number.EPSILON){t.normalize();const e=Math.acos(Math.min(Math.max(h.dir.dot(c.dir),-1),1));c.up.applyMatrix4(u.makeRotationAxis(t,e))}c.right.crossVectors(c.dir,c.up).normalize()}c.dist=h.dist+p;const y=d.dot(l);c.widthScale=Math.min(1/Math.sqrt((1+y)/2),1.415)||1,c.sharp=Math.abs(y-1)>.05&&i,this.count++}},t.PathTubeGeometry=class extends c{constructor(t=1e3,e=!1){super(t,e)}_initByData(t,e={},s,i){const n=l(t,e,i);n&&0!==n.count?(this.setAttribute("position",new r.BufferAttribute(new Float32Array(n.position),3).setUsage(s||r.StaticDrawUsage)),this.setAttribute("normal",new r.BufferAttribute(new Float32Array(n.normal),3).setUsage(s||r.StaticDrawUsage)),this.setAttribute("uv",new r.BufferAttribute(new Float32Array(n.uv),2).setUsage(s||r.StaticDrawUsage)),i&&this.setAttribute("uv2",new r.BufferAttribute(new Float32Array(n.uv2),2).setUsage(s||r.StaticDrawUsage)),this.setIndex(n.position.length/3>65536?new r.Uint32BufferAttribute(n.indices,1):new r.Uint16BufferAttribute(n.indices,1))):this._initByMaxVertex(2,i)}update(t,e={}){const s=!!this.getAttribute("uv2"),r=l(t,e,s);r?(this._updateAttributes(r.position,r.normal,r.uv,s?r.uv2:null,r.indices),this.drawRange.count=r.count):this.drawRange.count=0}},Object.defineProperty(t,"__esModule",{value:!0})}));
